import{g as n,c as t,e as y,d as l,n as _,F as d,h as v,o as i,i as r,f as c,v as u,t as x}from"./app-Ba0Gw2Pi.js";import{_ as k}from"./flex-CcMPSLbL.js";import{_ as T}from"./plugin-vue_export-helper-DlAUqK2U.js";const j={class:"label-bottom"},C=["value"],A={class:"label-bottom"},D=["value"],N={class:"label-bottom"},U=["value"],q={class:"label-bottom"},I=["value"],S={class:"label-bottom"},B=["value"],H={__name:"flex.html",setup(G){const m=n("row"),p=n("nowrap"),f=n("flex-start"),g=n("flex-start"),b=n("flex-start"),w=n([{value:"row"},{value:"row-reverse"},{value:"column"},{value:"column-reverse"}]),z=n([{value:"nowrap"},{value:"wrap"},{value:"wrap-reverse"}]),F=n([{value:"flex-start"},{value:"flex-end"},{value:"center"},{value:"space-between"},{value:"space-around"}]),h=n([{value:"flex-start"},{value:"flex-end"},{value:"center"},{value:"baseline"},{value:"stretch"}]),V=n([{value:"flex-start"},{value:"flex-end"},{value:"center"},{value:"space-between"},{value:"space-around"}]);return(o,e)=>(i(),t("div",null,[e[11]||(e[11]=y('<h1 id="flex-布局" tabindex="-1" data-v-33c06175><a class="header-anchor" href="#flex-布局" data-v-33c06175><span data-v-33c06175>flex 布局</span></a></h1><h3 id="flexbox" tabindex="-1" data-v-33c06175><a class="header-anchor" href="#flexbox" data-v-33c06175><span data-v-33c06175>Flexbox：</span></a></h3><ol data-v-33c06175><li data-v-33c06175><p data-v-33c06175><strong data-v-33c06175>基本概念：</strong></p><ul data-v-33c06175><li data-v-33c06175>主轴和交叉轴的概念</li><li data-v-33c06175>flex 容器和 flex 项目的概念 <img src="'+k+'" alt="flex" loading="lazy" data-v-33c06175> 在 flex 容器中默认存在两条轴，水平主轴(main axis) 和垂直的交叉轴(cross axis), 在容器中的每个单元块被称之为 flex item，每个项目占据的主轴空间为 (main size), 占据的交叉轴的空间为 (cross size)。 这里需要强调，不能先入为主认为宽度就是 main size，高度就是 cross size，这个还要取决于你主轴的方向，如果你垂直方向是主轴，那么项目的高度就是 main size。</li></ul></li><li data-v-33c06175><p data-v-33c06175><strong data-v-33c06175>Flex 容器属性：</strong></p><ul data-v-33c06175><li data-v-33c06175><code data-v-33c06175>display: flex;</code> 定义一个 Flex 容器</li><li data-v-33c06175><code data-v-33c06175>flex-direction</code> 控制主轴的方向</li><li data-v-33c06175><code data-v-33c06175>justify-content</code> 控制主轴上的对齐方式</li><li data-v-33c06175><code data-v-33c06175>align-items</code> 控制交叉轴上的对齐方式</li><li data-v-33c06175><code data-v-33c06175>flex-wrap</code> 控制项目是否换行</li></ul></li><li data-v-33c06175><p data-v-33c06175><strong data-v-33c06175>Flex 项目属性：</strong></p><ul data-v-33c06175><li data-v-33c06175><code data-v-33c06175>flex</code> 设置项目的放大比例</li><li data-v-33c06175><code data-v-33c06175>order</code> 设置项目的排列顺序</li><li data-v-33c06175><code data-v-33c06175>align-self</code> 控制单个项目在交叉轴上的对齐方式</li></ul></li><li data-v-33c06175><p data-v-33c06175><strong data-v-33c06175>其他：</strong></p><ul data-v-33c06175><li data-v-33c06175>Flexbox 的响应式设计</li><li data-v-33c06175>Flexbox 和 Grid 的结合使用</li></ul></li></ol><p data-v-33c06175>Demo:</p>',4)),l("div",{class:"flex-box",style:_({flexDirection:m.value,flexWrap:p.value,justifyContent:f.value,alignItems:g.value,alignContent:b.value})},e[5]||(e[5]=[y('<div class="item-1" data-v-33c06175>item-1</div><div class="item-2" data-v-33c06175>item-2</div><div class="item-3" data-v-33c06175>item-3</div><div class="item-4" data-v-33c06175>item-4</div><div class="item-5" data-v-33c06175>item-5</div>',5)]),4),l("div",j,[e[6]||(e[6]=l("label",{class:"label-title"},"flex-direction: ",-1)),(i(!0),t(d,null,v(w.value,a=>(i(),t("label",{key:o.index},[r(l("input",{type:"radio","onUpdate:modelValue":e[0]||(e[0]=s=>m.value=s),value:a.value},null,8,C),[[u,m.value]]),c(" "+x(a.value),1)]))),128))]),l("div",A,[e[7]||(e[7]=l("label",{class:"label-title"},"flex-wrap: ",-1)),(i(!0),t(d,null,v(z.value,a=>(i(),t("label",{key:o.index},[r(l("input",{type:"radio","onUpdate:modelValue":e[1]||(e[1]=s=>p.value=s),value:a.value},null,8,D),[[u,p.value]]),c(" "+x(a.value),1)]))),128))]),l("div",N,[e[8]||(e[8]=l("label",{class:"label-title"},"justify-content: ",-1)),(i(!0),t(d,null,v(F.value,a=>(i(),t("label",{key:o.index},[r(l("input",{type:"radio","onUpdate:modelValue":e[2]||(e[2]=s=>f.value=s),value:a.value},null,8,U),[[u,f.value]]),c(" "+x(a.value),1)]))),128))]),l("div",q,[e[9]||(e[9]=l("label",{class:"label-title"},"align-items: ",-1)),(i(!0),t(d,null,v(h.value,a=>(i(),t("label",{key:o.index},[r(l("input",{type:"radio","onUpdate:modelValue":e[3]||(e[3]=s=>g.value=s),value:a.value},null,8,I),[[u,g.value]]),c(" "+x(a.value),1)]))),128))]),l("div",S,[e[10]||(e[10]=l("label",{class:"label-title"},"align-content: ",-1)),(i(!0),t(d,null,v(V.value,a=>(i(),t("label",{key:o.index},[r(l("input",{type:"radio","onUpdate:modelValue":e[4]||(e[4]=s=>b.value=s),value:a.value},null,8,B),[[u,b.value]]),c(" "+x(a.value),1)]))),128))])]))}},J=T(H,[["__scopeId","data-v-33c06175"]]),L=JSON.parse('{"path":"/code/website/css/flex.html","title":"flex 布局","lang":"zh-CN","frontmatter":{},"git":{"createdTime":1700403037000,"updatedTime":1700472710000,"contributors":[{"name":"ThomasHang","username":"ThomasHang","email":"11939838031@qq.com","commits":1,"url":"https://github.com/ThomasHang"},{"name":"储天航","username":"","email":"1193983801@qq.com","commits":1}]},"readingTime":{"minutes":2.19,"words":656},"filePathRelative":"code/website/css/flex.md","excerpt":"\\n<h3>Flexbox：</h3>\\n<ol>\\n<li>\\n<p><strong>基本概念：</strong></p>\\n<ul>\\n<li>主轴和交叉轴的概念</li>\\n<li>flex 容器和 flex 项目的概念\\n<img src=\\"/assets/images/learn/flex.png\\" alt=\\"flex\\" loading=\\"lazy\\">\\n在 flex 容器中默认存在两条轴，水平主轴(main axis) 和垂直的交叉轴(cross axis),\\n在容器中的每个单元块被称之为 flex item，每个项目占据的主轴空间为 (main size), 占据的交叉轴的空间为 (cross size)。\\n这里需要强调，不能先入为主认为宽度就是 main size，高度就是 cross size，这个还要取决于你主轴的方向，如果你垂直方向是主轴，那么项目的高度就是 main size。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>Flex 容器属性：</strong></p>\\n<ul>\\n<li><code>display: flex;</code> 定义一个 Flex 容器</li>\\n<li><code>flex-direction</code> 控制主轴的方向</li>\\n<li><code>justify-content</code> 控制主轴上的对齐方式</li>\\n<li><code>align-items</code> 控制交叉轴上的对齐方式</li>\\n<li><code>flex-wrap</code> 控制项目是否换行</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>Flex 项目属性：</strong></p>\\n<ul>\\n<li><code>flex</code> 设置项目的放大比例</li>\\n<li><code>order</code> 设置项目的排列顺序</li>\\n<li><code>align-self</code> 控制单个项目在交叉轴上的对齐方式</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>其他：</strong></p>\\n<ul>\\n<li>Flexbox 的响应式设计</li>\\n<li>Flexbox 和 Grid 的结合使用</li>\\n</ul>\\n</li>\\n</ol>"}');export{J as comp,L as data};
